\subsection{Permutációcsoportok}
\label{subsec:permutacio}
Minden véges csoport felírható permutációcsoportként, így a permutációcsoportok hatékony használata kiemelten fontos.
A ma is használt módszer Charles C. Sims-től származik 1970-ből (\cite{Sim70}), a hatékonyságán Donald E. Knuth ötlete javított sokat, amit 1991-ben publikált (\cite{Knu91}).
Az \ref{subsubsec:permdef}. alfejezet az alapvető definíciókról szól, amik szükségesek Sims módszerének megértéséhez,
az \ref{subsubsec:permss}. alfejezet arról szól, hogy hogyan tudunk egy tetszőleges módon megadott permutációcsoportnak a hatékony megadását megkonstruálni,
míg az \ref{subsubsec:permbt}. rész az itt előforduló főként backtrack-jellegű algoritmusokat részletezi.
Ez a fejezet egy nagyon rövid kivonata lényegében Seress Ákos közel 300 oldalas könyvének (\cite{Ser03}), ami részletesebben tárgyal erről a témakörröl.

\subsubsection{Bázisok és erős generátorrendszerek}
\label{subsubsec:permdef}
Legyen $G \le S_n = \Sym(\Omega)$.
A $B=(\beta_1,\beta_2,\dots,\beta_m)$ különböző $\Omega$-beli elemekből álló sorozatot $G$ bázisának hívjuk,
ha $G$-nek egyetlen olyan eleme van (mégpedig az egységelem), ami pontonként fixen tartja $B$-t, vagyis ha $G_B=\{1\}$.
Egy bázis mindig definiál egy
\begin{equation}
\label{eq:permlanc}
G = G^{[1]} \ge G^{[2]} \ge \dots \ge G^{[m]} \ge G^{[m+1]} = \{1\}
\end{equation}
részcsoport-láncot, ahol $G^{[i]}=G_{(\beta_1,\beta_2,\dots,\beta_{i-1})}=G_{\beta_1}\cap G_{\beta_2}\cap\dots\cap G_{\beta_{i-1}}$, vagyis a $B$ első $i-1$ elemét fixen tartó csoportelemek részcsoportja.
A bázis irredundáns, ha $\forall 1\le i \le m$-re $G^{[i]} > G^{[i+1]}$, vagyis ha a lánc $m+1$ különböző részcsoportból áll.
Mostantól csak irredundáns bázisokkal foglalkozunk.
$G^{[i]}$-ben $G^{[i+1]}$ mellékosztályai a $\beta_i^{G^{[i]}}$ orbit elemeinek felel meg, így $2 \le \left| G^{[i]} : G^{[i+1]} \right| \le n$.
Ezt felhasználva
\begin{equation}
\label{eq:permmeret}
2^m \le |G|=\prod_{i=1}^m \left| G^{[i]} : G^{[i+1]} \right| \le n^m
\end{equation}
Logaritmust véve, majd átrendezve
\begin{equation}
\label{eq:permmeret2}
\frac{\log |G|}{\log n} \le m = |B| \le \log |G|
\end{equation}
Különböző irredundáns bázisok lehetnek különböző méretűek, de nem lehet egy bázis "túl nagy" emiatt.

$S \subseteq G$ részhalmazt $G$ erős generátorrendszerének hívjuk (a $B$ bázisra nézve), ha $\forall 1\le i \le m+1$-re $\langle S \cap G^{[i]} \rangle = G^{[i]}$.
Ha adott egy erős generátorrendszer, akkor az \ref{subsubsec:orbit}. fejezetben leírt algoritmussal a $\beta_i^{G^{[i]}}$ orbitok könnyen kiszámolhatóak.
Ezeket az orbitokat fundamentális orbitoknak hívjuk.
Ha a kiszámolásuk során az orbit minden pontjához felírjuk, hogy melyik $G^{[i]}$-beli elem viszi oda $\beta_i$-t, akkor megkapjuk az $R_i$ transzverzálist,
vagyis a $G^{[i+1]}$ mellékosztályainak reprezentáns elemeit.
A transzverzálisokat, ha explicit számolnánk ki és tárolnánk, akkor $\Theta(n^2)$ idő és memória kellene hozzá.
Ezt elkerülhetjük az úgy nevezett Schreier-fák használatával.
A Schreier-fa adatszerkezet egy $(S_i, T_i)$ párokból álló sorozat, minden $\beta_i$ bázisponthoz tartozik egy pár.
$T_i$ egy irányított cimkézett fa, aminek pontjai a $\beta_i^{G^{[i]}}$ fundamentális orbit elemeinek felelnek meg.
Minden él a $\beta_i$ gyökér fele mutat és meg van cimkézve $S_i \subseteq G^{[i]}$ egy elemével.
Ha $\gamma_1$-ből $\gamma_2$-be megy egy él $h$ cimkével, az azt jelenti, hogy $\gamma_1^h=\gamma_2$.
Így ha akármelyik $\gamma$-ból végigmegyünk éleken $\beta_i$-ig és a cimkéket összeszorozzuk, akkor megkapjuk hogy melyik
permutáció viszi $\gamma$-t $\beta_i$-be. Így az $(S_i, T_i)$ pár meghatározza a $G^{[i+1]}$ részcsoport mellékosztályainak 
reprezentáns elemeinek az inverzét $G^{[i]}$-ben. Azért az inverzekkel csináltuk, mert a szitáláshoz az inverzekre van szükségünk.
A gyakorlatban $S_i$ felírása után (ehhez $O(|S_i|n)$ memória szükséges) $T_i$-t el tudjuk tárolni egy $n$-hosszú $V_i$ tömbben.
$\gamma \in \Omega$-ra $V_i[\gamma]$-t akkor és csak akkor definiáljuk, ha $\gamma \in \beta_i^{G^{[i]}}$,
és ilyenkor $V_i[\gamma]$ egy $S_i$ egy elemére mutató pointert tartalmaz, ami megfelel a $\gamma$-ból kiinduló egyetlen él cimkéjének.
Emiatt a tárolási mód miatt Sims eredetileg Schreier-vektoroknak hívta az adatszerkezetet.

Feltehetjük, hogy $1 \in R_i$, vagyis hogy az egységelemet írtuk fel olyan elemnek ami $\beta_i$-t önmagába viszi.
Ezeknek a transzverzálisoknak a segítségével $\forall g \in G$ kanonikus alakra hozható, azaz egyértelműen felírható ilyen elemek szorzataként.
Precízebben megfogalmazva $\forall g \in G$-nek pontosan egy olyan szorzatalakja létezik, amire $g = r_m r_{m-1} \dots r_1$, ahol $r_i \in R_i$.
Ez a szorzatalak algoritmikusan könnyen megtalálható a következőképpen: Adott $g \in G$-re először megkeressük azt az $r_1 \in R_1$-et, amire $\beta_1^g = \beta_1^{r_1}$.
Ezután $g_2 = g r_1^{-1}$-zel folytatjuk, megkeressük azt az $r_2 \in R_2$-t, amire $\beta_2^{g_2} = \beta_2^{r_2}$. $g_3 = g_2 r_2^{-1}$, és így tovább, folytatjuk amíg végig nem érünk.
$1 = g_{m+1} = g_{m} r_m^{-1}$ lesz az utolsó lépés, visszaszámolva $g = r_m r_{m-1} \dots r_1$-et kapjuk. Ezt az eljárást szitáló eljárásnak hívjuk.

A szitálás alkalmas egyben arra is, hogy egy $h \in \Sym(\Omega)$-beli elemről eldöntsük, hogy $G$-ben van-e.
Ha megpróbáljuk $h$-ra alkalmazni az eljárást és sikerrel járunk, akkor $h\in G$.
Két rész van az algoritmusban ahol elakadhatunk.
Lehet, hogy valamely $i \le m$-re $h_i = h r_1^{-1} r_2^{-1} \dots r_{i-1}^{-1}$-re nem találunk megfelelő $r_i$-t, mert $\beta_i^{h_i} \notin \beta_i^{G^{[i]}}$.
Lehet az is, hogy a végén $h_{m+1} \neq 1$.
Mindkét ilyen esetben nyilvánvalóan $h \notin G$, ilyenkor az utoljára kiszámolt $h_i$-t vagy $h_{m+1}$-et maradéknak hívjuk.

$G$ rendjét is könnyen kiszámolhatjuk egy erős generátorrendszer ismeretében, ugyanis $|G| = |\beta_1^{G^{[1]}}| |\beta_2^{G^{[2]}}| \dots |\beta_m^{G^{[m]}}| = |R_1| |R_2| \dots |R_m|$.

\subsubsection{Schreier-Sims algoritmus}
\label{subsubsec:permss}
Ha megadnak nekünk egy $G \le \Sym(\Omega)$ permutációcsoportot valahogyan (black-box csoportnak is tekinthetjük akár),
akkor ki kell tudnunk számolni egy bázisát és egy erős generátorrendszert, ahhoz hogy hatékonyan tudjunk vele dolgozni.
Ez a Schreier-Sims algoritmussal történik, ami a következő két lemmán alapszik.
\begin{lemma}[Schreier]
\label{thm:sims1}
Legyen $H \le G = \langle S \rangle$ és legyen $R$ jobb transzverzálisa $H$-nak $G$-ben, amire $1\in R$.
Jelöljük $g \in G$-re $Hg\cap R$ egyetlen elemét $\overline{g}$-vel.
Ilyenkor a
\begin{equation*}
T=\left\{ rs(\overline{rs})^{-1} \mid r\in R, s\in S \right\}
\end{equation*}
halmaz $H$-t generálja, vagyis $H=\langle T \rangle$. A $T$ halmaz elemeit $H$ Schreier-generátorainak hívjuk.
\end{lemma}
\begin{proof}
Definíció szerint $T \subseteq H$, így elég belátni, hogy $H \le \langle T \rangle$.
Legyen $h \in H$ tetszőleges, felírhatjuk $h = s_1 s_2 \dots s_k$ alakban, ahol $s_i \in S$.
Sorba definiáljuk $1 \le i \le k$-ra $r_i$-t és $t_i$-t, úgy hogy $h = t_1 t_2 \dots t_i r_i s_{i+1} s_{i+2} \dots s_k$ igaz legyen $\forall i$-re.
Kezdőértéknek vegyük $r_0=1$-et, ezzel $h = r_0 s_1 s_2 \dots s_k$.
Ha $r_{i-1}$ már definiált, akkor legyen $t_i=r_{i-1} s_i (\overline{r_{i-1} s_i})^{-1} \in T$ és $r_i = \overline{r_{i-1} s_i} \in R$.
Ezekre indukció szerint $h = t_1 t_2 \dots t_i r_i s_{i+1} s_{i+2} \dots s_k$ teljesül.
Ha végigértünk, akkor $h = t_1 t_2 \dots t_k r_k$ alakot kapunk.
Mivel $h \in H$ és $t_1 t_2 \dots t_k \in \langle T \rangle \le H$, ezért $r_k \in H\cap R = \{1\}$.
Így $h \in \langle T \rangle$.
\end{proof}
\begin{lemma}
\label{thm:sims2}
Legyen $\{\beta_1, \dots, \beta_m\} \subseteq \Omega$ és $G \le \Sym(\Omega)$.
Legyen $S_i \subseteq G^{[i]} = G_{(\beta_1, \dots, \beta_{i-1})}$ minden $1 \le i \le m$-re.
A rövidség kedvéért vezessük be az $S_{m+1} = \emptyset$ jelölést.
Ha $\langle S_1 \rangle = G$ és $\langle S_i \rangle_{\beta_i} = \langle S_{i+1} \rangle$ teljesül $1 \le i \le m$-re, akkor $B = (\beta_1, \dots, \beta_m)$
$G$-nek bázisa, és $S = \bigcup_{i=1}^m S_i$ erős generátorrendszer $B$-re nézve.
\end{lemma}
\begin{proof}
Teljes indukciót alkalmazunk, az indukciós feltevésünk az, hogy a $G' = \langle S_2 \rangle = G_{\beta_1}$ csoportnak $S' = \bigcup_{i=2}^m S_i$ erős generátorrendszere a $B' = \{\beta_2, \dots, \beta_m\}$ bázisra nézva.
Ellenőriznünk kell, hogy minden $1\le i \le m+1$-re $\langle S \cap G^{[i]} \rangle = G^{[i]}$.
$G^{[1]} = G$, így $i = 1$-re triviális.
A lemma feltevéséből $G^{[2]} = G_{\beta_1} = \langle S_1 \rangle_{\beta_1} = \langle S_2 \rangle \le \langle S \cap G_{\beta_1} \rangle \le G_{\beta_1} = G^{[2]}$, vagyis $i = 2$-re is készen vagyunk.
$i > 2$-re az indukciós feltevés miatt $G^{[i]} \ge \langle S \cap G_{(\beta_1, \dots, \beta_{i-1})} \rangle \ge \langle S' \cap G'_{(\beta_2, \dots, \beta_{i-1})} \rangle = G'_{(\beta_2, \dots, \beta_{i-1})} = G_{(\beta_1, \dots, \beta_{i-1})} = G^{[i]}$,
tehát $i > 2$-re is készen vagyunk.
Mivel az indukciós feltevést csak $m \ge 2$ esetén használtuk, a bizonyítással készen vagyunk.
\end{proof}
Ha adott $G = \langle T \rangle$, akkor annak egy erős generátorrendszerét a következőképpen kaphatjuk.
Az algoritmus futása közben nyilvántartunk egy $B = (\beta_1, \dots, \beta_m)$ listát egy irredundáns bázis már ismert elemeiről,
és minden $1 \le i \le m$-re egy $S_i \subseteq G_{(\beta_1, \dots, \beta_{i-1})}$ halmazt, amikre az \ref{thm:sims2}. lemmát szeretnénk majd alkalmazni.
Az algoritmus alatt $S_i$-ket fogjuk növelni, illetve új báziselemeket fogunk $B$-hez adni (ezáltal $m$-et is növelve), így ha eleinte $\langle S_1 \rangle = G$ teljesül,
akkor abban a helyzetben vagyunk készen, amikor minden $1 \le i \le m$-re $\langle S_i \rangle_{\beta_i} = \langle S_{i+1} \rangle$ teljesül.
Végig fent fogjuk tartani, hogy $\langle S_i \rangle \ge \langle S_{i+1} \rangle$ is fennáll minden $i$-re.
Kezdetben legyen $B = (\beta_1)$, ahol $\beta_1 \in \Omega$ olyan hogy $T$-nek legalább egy eleme mozgatja, és legyen $S_1 = T$, ezzel garantálva, hogy $\langle S_1 \rangle = G$ teljesüljön.
Azt mondjuk, hogy az algoritmus az $l$. szinten tart, ha minden $l < i \le m$-re teljesül $\langle S_i \rangle_{\beta_i} = \langle S_{i+1} \rangle$.
Kezdetben a második szintről indulunk, az algoritmus futása akkor ér véget, amikor az első szintre jutunk.

Amikor az $l$. szinten vagyunk, a következő történik:
Megnézzük, hogy $\langle S_l \rangle_{\beta_l} = \langle S_{l+1} \rangle$ teljesül-e.
Mivel $\langle S_l \rangle \ge \langle S_{l+1} \rangle$, valamint $S_l \subseteq G_{(\beta_1, \dots, \beta_{l-1})}$, ezért elegendő a $\langle S_l \rangle_{\beta_l} \le \langle S_{l+1} \rangle$ irányú tartalmazást belátnunk.
Az \ref{thm:sims1}. lemma alapján $\langle S_l \rangle_{\beta_l} = \langle rs(\overline{rs})^{-1} \mid r\in R_l, s\in S_l \rangle$, ahol $R_l$ az $\langle S_l \rangle_{\beta_l}$ részcsoport transzverzálisa $\langle S_l \rangle$-ban.
Meg kell néznünk, hogy az összes Schreier-generátor benne van-e $\langle S_{l+1} \rangle$-ben.
Ezt az előző részben leírt módon tudjuk ellenőrizni, mivel az \ref{thm:sims2}. lemma szerint $\langle S_{l+1} \rangle$-nek már ismerjük egy erős generátorrendszerét.
Ha mind benne van, vagyis ha $\langle S_l \rangle_{\beta_l} = \langle S_{l+1} \rangle$ teljesül, akkor az $l-1$. szintre lépünk.
Ha nincs benne mind, vagyis $\langle S_l \rangle_{\beta_l} > \langle S_{l+1} \rangle$, akkor a szitálás során, amit kaptunk maradékot arra a Schreier-generátorra, ami nincs benne $\langle S_{l+1} \rangle$-ben,
azt vegyük hozzá az $S_{l+1}$ halmazhoz.
Ettől a hozzávételtől $\langle S_1 \rangle \ge \langle S_2 \rangle \ge \dots \ge \langle S_{m+1} \rangle$ továbbra is fennáll, valamint $S_{l+1} \subseteq G_{(\beta_1, \dots, \beta_{l})}$ is igaz marad.
$l = m$ esetén $B$-hez vegyünk hozzá egy olyan $\Omega$-beli elemet, amit a maradék nem hagy helyben.
Ezután az algoritmus az $l+1$. szinten folytatódik.

Az algoritmus mindenképpen véges, hiszen $\Omega$ véges, így csak véges sokszor tudtuk $B$-t növelni.
Ha a transzverzálisok számolásakor explicit leírunk minden elemet, akkor $O(|\Omega|^2 \log^3(|G|) + |T||\Omega|^2 \log(|G|))$ a futásidő, és $O(|\Omega|^2 \log(|G|) + |T||\Omega|)$ a memóriaigény.
Ha Schreier-fákkal számoltunk, akkor $O(|\Omega|^3 \log^3(|G|) + |T||\Omega|^3 \log(|G|))$ a futásidő, és $O(|\Omega| \log^2(|G|) + |T||\Omega|)$ a memóriaigény.
Ezeknek a bizonyítása megtalálható \cite{Ser03}-ban, valamint \cite{Mur03}-ban olvashatjuk az algoritmusnak rengeteg változatát részletesen elemezve, hogy mikor melyik a legalkalmasabb.

\todo{bizonyitas lehet hogy kene futasidokhoz}

\subsubsection{Backtrack módszerek}
\label{subsubsec:permbt}
Ebben a részben legyen adott $G$ és legyen $\mathcal{P}$ egy tulajdonság, meg kell találnunk $G(\mathcal{P})$-t, vagyis $G$ azon elemeit, amik $\mathcal{P}$ tulajdonságúak.
Ehhez feltesszük, hogy minden $g \in G$-re el tudjuk dönteni, hogy $\mathcal{P}$ tulajdonságú-e.
Néhány tulajdonságra nincs ismert jobb algoritmus annál, mint hogy végigmegyünk $G$ elemein, és mindegyiket ellenőrizzük.
Gyakori eset azonban, hogy $G(\mathcal{P})$, ha nem üres, akkor $G$ egy részcsoportja, esetleg egy részcsoport mellékosztálya.
Például, ha egy elem vagy egy részhalmaz centralizátorát szeretnénk megtalálni, akkor egy részcsoportot keresünk.
Mellékosztályra példa, ha $a, b \in G$-re azokat a $g \in G$-ket keressük, amelyek $a$-t $b$-be konjugálják, vagyis amelyekre $a^g = b$.
Gyakran elegendő azt eldöntenünk, hogy $G(\mathcal{P})$ üres-e, az előző példánál ez annak eldöntését jelenti, hogy $a$ és $b$ konjugáltak-e.
Ebben a részben feltesszük, hogy $G(\mathcal{P})$ egy részcsoport, egy részcsoport mellékosztálya vagy üres.

Legyen $B=(\beta_1,\dots,\beta_m)$ a $G \le \Sym(\Omega)$ csoport egy bázisa, és legyen $G = G^{[1]} \ge G^{[2]} \ge \dots \ge G^{[m]} \ge G^{[m+1]} = \{1\}$ az ehhez tartozó részcsoportlánc.
$G$ minden elemét egyértelműen meghatározza az, hogy $B$ elemeit hova viszi, így a báziselemek képeinek sorozátaval azonosíthatjuk a csoportelemeket.
Ha csak az első $k$ báziselem képét adjuk meg, akkor az $G^{[k+1]}$ egy mellékosztályát adja meg.
Az összes ilyen kezdőszelet meghatároz egy keresési fát, hogy hogyan tudunk $G$-beli elemeket keresni.
Az egyetlen $0$-hosszú kezdőszelet $G$-nek felel meg (ebből indulunk), az $m$-hosszúak felelnek meg az elemeknek.
Jelöljük a kezdőszeletek halmazát $T$-vel, legyen $\varphi : T \to P(G)$, amire $\varphi((\alpha_1,\dots,\alpha_k)) = \left\{ g \in G \mid \beta_i^g = \alpha_i \quad \forall 1 \le i \le k \right \}$.
Az algoritmusunk azt csinálja, hogy a kezdőszeleteken a $0$-hosszúból kiindulva mélységi bejárással végigmegyünk (mint más backtrack-algoritmusoknál is),
és közben minél többször megpróbáljuk valami alapján $t \in T$-t eldobni, hogy ne kelljen azon belül is folytatni a bejárást.
Ez történhet azért, mert valahogy belátjuk, hogy $\varphi(t) \cap G(\mathcal{P})$ üres, vagy már minden elemét ismerjük.
Ilyenkor $\varphi(t)$ elemei nem érdekesek már, így nem kell a bejárást folytatnunk a $t$-vel kezdődő kezdőszeleteken.
Vannak a $\mathcal{P}$ tulajdonságtól független és attól függő elvek, amik alapján egy $t$-t eldobhatunk. A következő lemma, az egyik legegyszerűbb $\mathcal{P}$-től független ilyen elvet mutatja be.
\begin{lemma}
Tegyük fel, hogy $G(\mathcal{P}) \le G$, a $K = G(\mathcal{P}) \cap G^{[l+1]}$ részcsoportot már ismerjük valamilyen $l \in \{1,\dots,m\}$-re és hogy most egy $t \in T$ $l$-hosszú kezdőszeletnél vagyunk.
Ha találunk egyetlen $g \in \varphi(t) \cap G(\mathcal{P})$-t, akkor $\varphi(t) \cap G(\mathcal{P}) \subseteq \langle g, K \rangle \subseteq G(\mathcal{P})$, így nem kell tovább néznünk a $t$-vel kezdődő kezdőszeleteket.
\end{lemma}
\begin{proof}
Minden $h \in \varphi(t) \cap G(\mathcal{P})$ a $Kg$ mellékosztályban található.
\end{proof}
\todo{egyéb $\mathcal{P}$-független elvek}
\todo{centralizátor}
\todo{$\Omega$ részhalmazának stabilizátora}
\todo{konjugáltság}